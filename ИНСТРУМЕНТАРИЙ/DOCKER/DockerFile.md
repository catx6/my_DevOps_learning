DockerFile - это инструкция для сборки [[Image]]
это рецепт из слоев описывающие 
- из какого базового образа начать
- установочные пакеты
- какие файлы скопировать
- какие команды запустить
- какой процесс выполнить при старте контейнера


| команда       | назначение                                                            | пример                                          |
| ------------- | --------------------------------------------------------------------- | ----------------------------------------------- |
| `FROM`        | указывает базовый образ                                               | `FROM ubuntu:22.04`                             |
| `WORKDIR`     | устанавливает рабочую директорию                                      | `WORKDIR /usr/src/app`                          |
| `COPY`        | копирует файлы в контейнер                                            | `COPY . /app`                                   |
| `ADD`         | то же но может скачивать URL или распоковал архив                     | `ADD app.tar.gz /app`                           |
| `RUN`         | выполняет команду при сборке образа                                   | `RUN apt-get update && apt-get install -y curl` |
| `CMD`         | определяет команду запускаемую по умолчанию                           | `CMD ["python", "app.py"]`                      |
| `EMTRYPOINT`  | определяет основную команду, которую нельзя переопределить просто так | `ENTRYPOINT ["nginx", "-g", "daemon off;"]`     |
| `ENV`         | устанавливает переменные окружения                                    | `ENV PORT=8080`                                 |
| `EXPOSE`      | документирует порты которые контейнер слушает                         | `EXPOSE 8080`                                   |
| `VOLUME`      | указывает какие директории должны быть внешними томами                | `VOLUME /data`                                  |
| `USER`        | указывает от какого пользователя выполнять команды                    | `USER appuser`                                  |
| `LABEL`       | добавлять метаданные                                                  | `LABAL maintainer="devops@mail.ru"`             |
| `ARG`         | аргументы сборки, задаются при `docker build`                         | `ARG VERSION=1.0`                               |
| `HEALTHCHECK` | проверяет жив ли контейнер                                            | `HEALTHCHECK CMD curl -f http:localhost:8080`   |
| `SHELL`       | меняет используемую оболочку                                          | `SHELL ["/bin/bash", "-c"]`                     |
`изменение последнего слоя не затронут прошлые, но изменения первого изменят все`

---

### оптимизация

1. использование легких образов - `alpine`, `slim`, `distroless`
2. минимизировать кол-во слоев - объединять `RUN` команды `&&`
3. сначало зависимости потом код
4. удалять лишнее - кеши, логи, временные файлы
5. не запускать с root - создавать нового пользователя
6. хранить конфиги через ENV/ARG а не в коде
7. использовать `.dockerignore` - исключая ненужные файлы

| Ошибка                              | Почему плохо            | Как исправить                                        |
| ----------------------------------- | ----------------------- | ---------------------------------------------------- |
| Копирование `.` без `.dockerignore` | Тянет мусор в образ     | Добавь `.dockerignore`                               |
| Запуск от root                      | Опасно в проде          | Добавь `USER appuser`                                |
| Много `RUN` слоёв                   | Замедляет сборку        | Объедини `RUN apt-get update && apt-get install ...` |
| Использование `latest`              | Неконтролируемая версия | Указывай точный тег                                  |
| Хранение секретов в ENV             | Утечка данных           | Используй Docker Secrets / env-файлы                 |

---

#### docker build

`docker build -t app:version -f /path/to/dockerfile` -
- `-t задает тег`
- `-f указывает путь до dockerfile`

также при сборке можно указать архитектуру через флаг 
- `--platform linux/amd64`
- `--platform linux/arm64`
- `--platform linux/amd64`