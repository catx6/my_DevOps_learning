указатели - **переменная**, *хранит адрес* другой переменной
- обычная переменная -> хранит значение
- указатель - хранит место где лежит значение
```go
x := 10 // переменная хранит значение в оперативной памяти
valueAdress := &x // переменная хранит адресс значения 0x000b1ef
fmt.Println(*valueAdress) //разыменовывание получает значение по адресу
```
-> `*valueAdress` - получает значение по адресу 0x000b1ef, читает значение

##### что можно делать с указателями
```go
x := 10 //x=10
p := &x //p=0x000f1f1
*p = 20 // *p=20 изменил значение по адресу
fmt.Println(x) // 20
```
-> изменение значения оригинальных переменных
```go
func inc(n *int) { // указатель на int 
    *n = *n + 1 // указатель который содержит адрес x
}

func main() {
    x := 5        // x=5 выделение памяти в адресе 0x0000bc2
    inc(&x)       // вызов переменной и получение адреса x 
    fmt.Println(x) // 6
}
```
-> `*int` указатель инт хранит адресс переменной, является отдельным типом данных

```go
func in(x int) {
	x += 5
}
func main() {
	var x int = 1
	var p *int = &x
	in(x)
	fmt.Println(x, p)
}
```
-> что я понял
- переменная изменилась локально func in
- если использовать указатели измениться значение по адресу
- возврат значения return x вернет значение локально измененной x
#### зачем нужны указатели

1. Изменять данные у вызывающей стороны (мутабельность)
оригинальную переменную надо изменять по ее адресу
2. экономия времени и памяти 
если есть большая структура то при передаче значения весь объект копируется
указатель же укажет на его положение что займет ОЧЕНЬ мало памяти
`передавая структуру в килобайт лучше использовать указатели они занимают 8байт`
3. работа с ресурсами и состоянием
указатели позволяют держать одно и то же состояние в разных местах программы
4. интерфейстность и nil
Указатели могут быть `nil` - удобный маркер что объект не задан.
для сигнализации того что объекта нету 
указатель выдает `nil` из за отсутсвия объекта

