system call - точка входа из user space в kernel space
когда программа хочет 
- прочитать/записать данные 
- выделить память 
- запустить процесс

---

|Категория|Примеры|
|---|---|
|Работа с файлами|`open()`, `read()`, `write()`, `close()`|
|Процессы|`fork()`, `execve()`, `waitpid()`|
|Память|`mmap()`, `brk()`|
|Сеть|`socket()`, `connect()`, `sendto()`, `recvfrom()`|
|Управление|`chmod()`, `chown()`, `kill()`|
|Синхронизация|`futex()`, `clone()`|
для DevOps инженера syscalls нужны не часто но чтобы выявить ошибки например в процессах почему висит приложение или зависает i/o и т.д они полезны

----

#### пример на C

```C
write(1, "Hello\n", 6);
```
на самом деле функция `write()` — это **обёртка** из стандартной библиотеки glibc,  
которая внутри вызывает **системный вызов ядра** `syscall(SYS_write, ...)`.

```C
#include <unistd.h>     // для syscall()
#include <sys/syscall.h> // для констант SYS_write
#include <stdio.h>

int main() {
    const char *msg = "Hello from syscall!\n";
    syscall(SYS_write, 1, msg, 20);  // (номер syscalls, fd=1, buf, len)
    return 0;
}
```
компиляция:
```bash
gcc syscall_example.c -o syscall_example
./syscall_example
```

### кратко
syscalls - системный вызов это интерфейс между пользователем и системой

---
#### пример
как работает команда cat
- /bin/bash разбирает строку и 1 слово интерпритируется как исполняемый файл 
- оболочка ищет cat в переменной окружения `PATH` обычно это `/bin` там же внутри `/bin` лежит исполняемый /cat
- **запуск процесса** оболочка делает syscall `fork()`
- создание дочернего процесса 
- затем `execve()` загружает в него исполняемый файл `/bin/cat` с переданными аргументами `argb=["cat", "large_file.txt"]`
- **Инициализация открытия файла** парсинг аргументов
- открытие файла с помощью syscall `open()`
- получает файловый дескриптор
- `cat` читает содержимое файла поблочно(обычно 131072 байт зависит от реализации системы)
- каждый блок читается с помощью syscall `read()`
- затем данные записываются в стандартный вывод с помощью syscall `write()` 
- весь процесс идет пока не произойдет ошибка или когда будет прочитан **весь** файл
- после окончания `cat` закрывает файл (неявно при завершении файловой дескриптор освобождается ОС)
- процесс завершается с syscall `exit(0)` при успехе
-> cat не хранит весь файл в озу и перенаправляет весь вывод в `stdout`
итог: 6 системных вызовов на простую команду с минимальными аргументами